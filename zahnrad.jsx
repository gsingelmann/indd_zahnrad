#targetengine gs_cogwheel2if ( app.documents.length ) {	main();} else {	alert("Kein Dokument offen");}function init_cog() {	var is_ai = app.name.search(/illustrator/i) != -1;	var doc = app.activeDocument,	item;	if ( is_ai ) {		item = doc.pathItems.rectangle(-10, 10, 100, 100);	} else {		item = doc.rectangles.add( {geometricBounds: [ 10, 10, 100, 100 ]Ê}Ê);	}	return item;}function update_cog( item, path ) {	var is_ai = app.name.search(/illustrator/i) != -1;		if ( is_ai ) {		item.setEntirePath( path );	} else {		item.paths[0].entirePath = path;	}}function calc_path( state, item ) {	// https://stackoverflow.com/questions/23527362/how-to-draw-a-cogwheel-in-html5-canvas	var cx      = state.x_center,			cy      = state.y_center,			notches = state.notches,			radiusO = state.radius_o,			radiusI = state.radius_i,			taperO  = state.taper_o,			taperI  = state.taper_i,			// pre-calculate values for loop			pi2     = 2 * Math.PI,            // cache 2xPI (360deg)			angle   = pi2 / (notches * 2),    // angle between notches			taperAI = angle * taperI * 0.005, // inner taper offset (100% = half notch)			taperAO = angle * taperO * 0.005, // outer taper offset			a       = angle,                  // iterator (angle)			toggle  = false;                  // notch radius level (i/o)							var path = [];			// move to starting point	//ctx.moveTo(cx + radiusO * Math.cos(taperAO), cy + radiusO * Math.sin(taperAO));	path.push( [cx + radiusO * Math.cos(taperAO), cy + radiusO * Math.sin(taperAO) ] );	// loop	for (; a <= pi2; a += angle) {			// draw inner to outer line			if (toggle) {				/*					ctx.lineTo(cx + radiusI * Math.cos(a - taperAI),										 cy + radiusI * Math.sin(a - taperAI));					ctx.lineTo(cx + radiusO * Math.cos(a + taperAO),										 cy + radiusO * Math.sin(a + taperAO));					*/					path.push( [ cx + radiusI * Math.cos(a - taperAI),										 cy + radiusI * Math.sin(a - taperAI) ] );					path.push( [ cx + radiusO * Math.cos(a + taperAO),										 cy + radiusO * Math.sin(a + taperAO) ]Ê);			}			// draw outer to inner line			else {				/*					ctx.lineTo(cx + radiusO * Math.cos(a - taperAO),  // outer line										 cy + radiusO * Math.sin(a - taperAO));					ctx.lineTo(cx + radiusI * Math.cos(a + taperAI),  // inner line										 cy + radiusI * Math.sin(a + taperAI));				*/					path.push( [ cx + radiusO * Math.cos(a - taperAO), 											cy + radiusO * Math.sin(a - taperAO) ] );					path.push( [ cx + radiusI * Math.cos(a + taperAI), 											cy + radiusI * Math.sin(a + taperAI) ] );			}			// switch level			toggle = !toggle;	}	return path;}function main() {	var item = init_cog();	update_cog( item, [Ê[0, 0], [100, 50], [50, 100], [0, 0]Ê] );				// ----------------------------------------------------------------	//	Die Dialogkomponenten selbst	// ----------------------------------------------------------------	var std_w = 400, std_h = 100;	var sld_lbl_w = 100;	var w = new Window("palette");	w.orientation = "column";	w.alignChildren = ["fill", "fill" ];	// ----------------------------------------------------------------	// Um Eingaben rŸckgŠngig machen zu kšnnen, mŸssen wir uns alle Werte merken	// Macht das Auswerten auch leichter ;)	// ----------------------------------------------------------------	w.state = {}	w.state.x_center = 60	w.state.y_center = 60	w.state.notches = 16	w.state.radius_o = 50	w.state.radius_i = 40	w.state.taper_o = 50	w.state.taper_i = 25	var aux_path = calc_path( w.state, item );	update_cog( item, aux_path );			// ----------------- group: cnt	w.cnt = w.add("group", undefined , "")	w.cnt.orientation = "row"	w.cnt.alignChildren = ["fill", "fill"]	// ----------------- group: sld	w.cnt.sld = w.cnt.add("group", undefined , "")	w.cnt.sld.orientation = "column"	w.cnt.sld.alignChildren = ["fill", "fill"]	// ----------------- slider: x_center	w.cnt.sld.x_center_group = w.cnt.sld.add("group", undefined, "", {orientation: "row"})	w.cnt.sld.x_center_group.add("statictext", [undefined, undefined, sld_lbl_w, 20], "Mitte X")	w.cnt.sld.x_center = w.cnt.sld.x_center_group.add("slider", [undefined, undefined, (std_w - (sld_lbl_w + 30)), 20], "")	w.cnt.sld.x_center_fd = w.cnt.sld.x_center_group.add("edittext", [undefined, undefined, 30, 20], "")	w.cnt.sld.x_center.minvalue = 0	w.cnt.sld.x_center.maxvalue = 100	w.cnt.sld.x_center.value = w.state.x_center	w.cnt.sld.x_center_fd.text = w.state.x_center	w.cnt.sld.x_center.id = "x_center"	w.cnt.sld.x_center.onChange = function() {		w.cnt.sld.x_center_fd.text = this.value;		this.window.state[ this.id ] = this.value;		var aux_path = calc_path( this.window.state, item );		update_cog( item, aux_path );		}	w.cnt.sld.x_center_fd.onChange = function() {		if ( ! isNaN( Number( this.text ) ) ) {			w.cnt.sld.x_center.value = Number(this.text)			w.state.x_center = Number( this.text)		} else {			this.text = w.cnt.sld.x_center.value		}	}	// ----------------- slider: y_center	w.cnt.sld.y_center_group = w.cnt.sld.add("group", undefined, "", {orientation: "row"})	w.cnt.sld.y_center_group.add("statictext", [undefined, undefined, sld_lbl_w, 20], "Mitte Y")	w.cnt.sld.y_center = w.cnt.sld.y_center_group.add("slider", [undefined, undefined, (std_w - (sld_lbl_w + 30)), 20], "")	w.cnt.sld.y_center_fd = w.cnt.sld.y_center_group.add("edittext", [undefined, undefined, 30, 20], "")	w.cnt.sld.y_center.minvalue = 0	w.cnt.sld.y_center.maxvalue = 100	w.cnt.sld.y_center.value = w.state.y_center	w.cnt.sld.y_center_fd.text = w.state.y_center	w.cnt.sld.y_center.id = "y_center"	w.cnt.sld.y_center.onChange = function() {		w.cnt.sld.y_center_fd.text = this.value		this.window.state[ this.id ] = this.value		var aux_path = calc_path( this.window.state, item );		update_cog( item, aux_path );		}	w.cnt.sld.y_center_fd.onChange = function() {		if ( ! isNaN( Number( this.text ) ) ) {			w.cnt.sld.y_center.value = Number(this.text)			w.state.y_center = Number( this.text)		} else {			this.text = w.cnt.sld.y_center.value		}	}	// ----------------- slider: notches	w.cnt.sld.notches_group = w.cnt.sld.add("group", undefined, "", {orientation: "row"})	w.cnt.sld.notches_group.add("statictext", [undefined, undefined, sld_lbl_w, 20], "ZŠhne")	w.cnt.sld.notches = w.cnt.sld.notches_group.add("slider", [undefined, undefined, (std_w - (sld_lbl_w + 30)), 20], "")	w.cnt.sld.notches_fd = w.cnt.sld.notches_group.add("edittext", [undefined, undefined, 30, 20], "")	w.cnt.sld.notches.minvalue = 0	w.cnt.sld.notches.maxvalue = 100	w.cnt.sld.notches.value = w.state.notches	w.cnt.sld.notches_fd.text = w.state.notches	w.cnt.sld.notches.id = "notches"	w.cnt.sld.notches.onChange = function() {		w.cnt.sld.notches_fd.text = this.value		this.window.state[ this.id ] = this.value		var aux_path = calc_path( this.window.state, item );		update_cog( item, aux_path );		}	w.cnt.sld.notches_fd.onChange = function() {		if ( ! isNaN( Number( this.text ) ) ) {			w.cnt.sld.notches.value = Number(this.text)			w.state.notches = Number( this.text)		} else {			this.text = w.cnt.sld.notches.value		}	}	// ----------------- slider: radius_o	w.cnt.sld.radius_o_group = w.cnt.sld.add("group", undefined, "", {orientation: "row"})	w.cnt.sld.radius_o_group.add("statictext", [undefined, undefined, sld_lbl_w, 20], "Radius au§en")	w.cnt.sld.radius_o = w.cnt.sld.radius_o_group.add("slider", [undefined, undefined, (std_w - (sld_lbl_w + 30)), 20], "")	w.cnt.sld.radius_o_fd = w.cnt.sld.radius_o_group.add("edittext", [undefined, undefined, 30, 20], "")	w.cnt.sld.radius_o.minvalue = 0	w.cnt.sld.radius_o.maxvalue = 100	w.cnt.sld.radius_o.value = w.state.radius_o	w.cnt.sld.radius_o_fd.text = w.state.radius_o	w.cnt.sld.radius_o.id = "radius_o"	w.cnt.sld.radius_o.onChange = function() {		w.cnt.sld.radius_o_fd.text = this.value		this.window.state[ this.id ] = this.value		var aux_path = calc_path( this.window.state, item );		update_cog( item, aux_path );		}	w.cnt.sld.radius_o_fd.onChange = function() {		if ( ! isNaN( Number( this.text ) ) ) {			w.cnt.sld.radius_o.value = Number(this.text)			w.state.radius_o = Number( this.text)		} else {			this.text = w.cnt.sld.radius_o.value		}	}	// ----------------- slider: radius_i	w.cnt.sld.radius_i_group = w.cnt.sld.add("group", undefined, "", {orientation: "row"})	w.cnt.sld.radius_i_group.add("statictext", [undefined, undefined, sld_lbl_w, 20], "Radius innen")	w.cnt.sld.radius_i = w.cnt.sld.radius_i_group.add("slider", [undefined, undefined, (std_w - (sld_lbl_w + 30)), 20], "")	w.cnt.sld.radius_i_fd = w.cnt.sld.radius_i_group.add("edittext", [undefined, undefined, 30, 20], "")	w.cnt.sld.radius_i.minvalue = 0	w.cnt.sld.radius_i.maxvalue = 100	w.cnt.sld.radius_i.value = w.state.radius_i	w.cnt.sld.radius_i_fd.text = w.state.radius_i	w.cnt.sld.radius_i.id = "radius_i"	w.cnt.sld.radius_i.onChange = function() {		w.cnt.sld.radius_i_fd.text = this.value		this.window.state[ this.id ] = this.value		var aux_path = calc_path( this.window.state, item );		update_cog( item, aux_path );		}	w.cnt.sld.radius_i_fd.onChange = function() {		if ( ! isNaN( Number( this.text ) ) ) {			w.cnt.sld.radius_i.value = Number(this.text)			w.state.radius_i = Number( this.text)		} else {			this.text = w.cnt.sld.radius_i.value		}	}	// ----------------- slider: taper_o	w.cnt.sld.taper_o_group = w.cnt.sld.add("group", undefined, "", {orientation: "row"})	w.cnt.sld.taper_o_group.add("statictext", [undefined, undefined, sld_lbl_w, 20], "VerjŸngung au§en")	w.cnt.sld.taper_o = w.cnt.sld.taper_o_group.add("slider", [undefined, undefined, (std_w - (sld_lbl_w + 30)), 20], "")	w.cnt.sld.taper_o_fd = w.cnt.sld.taper_o_group.add("edittext", [undefined, undefined, 30, 20], "")	w.cnt.sld.taper_o.minvalue = 0	w.cnt.sld.taper_o.maxvalue = 100	w.cnt.sld.taper_o.value = w.state.taper_o	w.cnt.sld.taper_o_fd.text = w.state.taper_o	w.cnt.sld.taper_o.id = "taper_o"	w.cnt.sld.taper_o.onChange = function() {		w.cnt.sld.taper_o_fd.text = this.value		this.window.state[ this.id ] = this.value		var aux_path = calc_path( this.window.state, item );		update_cog( item, aux_path );		}	w.cnt.sld.taper_o_fd.onChange = function() {		if ( ! isNaN( Number( this.text ) ) ) {			w.cnt.sld.taper_o.value = Number(this.text)			w.state.taper_o = Number( this.text)		} else {			this.text = w.cnt.sld.taper_o.value		}	}	// ----------------- slider: taper_i	w.cnt.sld.taper_i_group = w.cnt.sld.add("group", undefined, "", {orientation: "row"})	w.cnt.sld.taper_i_group.add("statictext", [undefined, undefined, sld_lbl_w, 20], "VerjŸngung innen ")	w.cnt.sld.taper_i = w.cnt.sld.taper_i_group.add("slider", [undefined, undefined, (std_w - (sld_lbl_w + 30)), 20], "")	w.cnt.sld.taper_i_fd = w.cnt.sld.taper_i_group.add("edittext", [undefined, undefined, 30, 20], "")	w.cnt.sld.taper_i.minvalue = 0	w.cnt.sld.taper_i.maxvalue = 100	w.cnt.sld.taper_i.value = w.state.taper_i	w.cnt.sld.taper_i_fd.text = w.state.taper_i	w.cnt.sld.taper_i.id = "taper_i"	w.cnt.sld.taper_i.onChange = function() {		w.cnt.sld.taper_i_fd.text = this.value		this.window.state[ this.id ] = this.value		var aux_path = calc_path( this.window.state, item );		update_cog( item, aux_path );		}	w.cnt.sld.taper_i_fd.onChange = function() {		if ( ! isNaN( Number( this.text ) ) ) {			w.cnt.sld.taper_i.value = Number(this.text)			w.state.taper_i = Number( this.text)		} else {			this.text = w.cnt.sld.taper_i.value		}	}	// ----------------- group: btns	w.cnt.btns = w.cnt.add("group", undefined , "")	w.cnt.btns.orientation = "column"	w.cnt.btns.alignChildren = ["fill", "top"]	// ----------------- button: defaultElement	w.defaultElement = w.cnt.btns.add("button", undefined, "OK")	w.defaultElement.onClick= function() {	  $.writeln("state\n" + this.window.state.toSource() );		w.close(1);		this.window.close();	}	// ----------------- button: cancelElement	w.cancelElement = w.cnt.btns.add("button", undefined, "Abbrechen")	w.cancelElement.onClick= function() {		item.remove();		this.window.close(2)	}	w.show();}